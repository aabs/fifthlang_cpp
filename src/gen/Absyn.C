//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <vector>
#include "Absyn.H"

/********************   FifthProgram    ********************/
FifthProgram::FifthProgram(ListModuleImport *p1, ListAlias *p2, ListStatement *p3, ListFunctionDeclaration *p4)
{
  listmoduleimport_ = p1;
  listalias_ = p2;
  liststatement_ = p3;
  listfunctiondeclaration_ = p4;

}

FifthProgram::FifthProgram(const FifthProgram & other)
{
  listmoduleimport_ = other.listmoduleimport_->clone();
  listalias_ = other.listalias_->clone();
  liststatement_ = other.liststatement_->clone();
  listfunctiondeclaration_ = other.listfunctiondeclaration_->clone();

}

FifthProgram &FifthProgram::operator=(const FifthProgram & other)
{
  FifthProgram tmp(other);
  swap(tmp);
  return *this;
}

void FifthProgram::swap(FifthProgram & other)
{
  std::swap(listmoduleimport_, other.listmoduleimport_);
  std::swap(listalias_, other.listalias_);
  std::swap(liststatement_, other.liststatement_);
  std::swap(listfunctiondeclaration_, other.listfunctiondeclaration_);

}

FifthProgram::~FifthProgram()
{
  delete(listmoduleimport_);
  delete(listalias_);
  delete(liststatement_);
  delete(listfunctiondeclaration_);

}

void FifthProgram::accept(Visitor *v)
{
  v->visitFifthProgram(this);
}

FifthProgram *FifthProgram::clone() const
{
  return new FifthProgram(*this);
}



/********************   AliasUri    ********************/
AliasUri::AliasUri(UriConstant *p1, PackageName *p2)
{
  uriconstant_ = p1;
  packagename_ = p2;

}

AliasUri::AliasUri(const AliasUri & other)
{
  uriconstant_ = other.uriconstant_->clone();
  packagename_ = other.packagename_->clone();

}

AliasUri &AliasUri::operator=(const AliasUri & other)
{
  AliasUri tmp(other);
  swap(tmp);
  return *this;
}

void AliasUri::swap(AliasUri & other)
{
  std::swap(uriconstant_, other.uriconstant_);
  std::swap(packagename_, other.packagename_);

}

AliasUri::~AliasUri()
{
  delete(uriconstant_);
  delete(packagename_);

}

void AliasUri::accept(Visitor *v)
{
  v->visitAliasUri(this);
}

AliasUri *AliasUri::clone() const
{
  return new AliasUri(*this);
}



/********************   Blk    ********************/
Blk::Blk(ListStatement *p1)
{
  liststatement_ = p1;

}

Blk::Blk(const Blk & other)
{
  liststatement_ = other.liststatement_->clone();

}

Blk &Blk::operator=(const Blk & other)
{
  Blk tmp(other);
  swap(tmp);
  return *this;
}

void Blk::swap(Blk & other)
{
  std::swap(liststatement_, other.liststatement_);

}

Blk::~Blk()
{
  delete(liststatement_);

}

void Blk::accept(Visitor *v)
{
  v->visitBlk(this);
}

Blk *Blk::clone() const
{
  return new Blk(*this);
}



/********************   FParam    ********************/
FParam::FParam(ParamType *p1, ParamName *p2)
{
  paramtype_ = p1;
  paramname_ = p2;

}

FParam::FParam(const FParam & other)
{
  paramtype_ = other.paramtype_->clone();
  paramname_ = other.paramname_->clone();

}

FParam &FParam::operator=(const FParam & other)
{
  FParam tmp(other);
  swap(tmp);
  return *this;
}

void FParam::swap(FParam & other)
{
  std::swap(paramtype_, other.paramtype_);
  std::swap(paramname_, other.paramname_);

}

FParam::~FParam()
{
  delete(paramtype_);
  delete(paramname_);

}

void FParam::accept(Visitor *v)
{
  v->visitFParam(this);
}

FParam *FParam::clone() const
{
  return new FParam(*this);
}



/********************   FuncDecl    ********************/
FuncDecl::FuncDecl(FunctionName *p1, ListFormalParameter *p2, Block *p3)
{
  functionname_ = p1;
  listformalparameter_ = p2;
  block_ = p3;

}

FuncDecl::FuncDecl(const FuncDecl & other)
{
  functionname_ = other.functionname_->clone();
  listformalparameter_ = other.listformalparameter_->clone();
  block_ = other.block_->clone();

}

FuncDecl &FuncDecl::operator=(const FuncDecl & other)
{
  FuncDecl tmp(other);
  swap(tmp);
  return *this;
}

void FuncDecl::swap(FuncDecl & other)
{
  std::swap(functionname_, other.functionname_);
  std::swap(listformalparameter_, other.listformalparameter_);
  std::swap(block_, other.block_);

}

FuncDecl::~FuncDecl()
{
  delete(functionname_);
  delete(listformalparameter_);
  delete(block_);

}

void FuncDecl::accept(Visitor *v)
{
  v->visitFuncDecl(this);
}

FuncDecl *FuncDecl::clone() const
{
  return new FuncDecl(*this);
}



/********************   NFunc    ********************/
NFunc::NFunc(Ident p1)
{
  ident_ = p1;

}

NFunc::NFunc(const NFunc & other)
{
  ident_ = other.ident_;

}

NFunc &NFunc::operator=(const NFunc & other)
{
  NFunc tmp(other);
  swap(tmp);
  return *this;
}

void NFunc::swap(NFunc & other)
{
  std::swap(ident_, other.ident_);

}

NFunc::~NFunc()
{

}

void NFunc::accept(Visitor *v)
{
  v->visitNFunc(this);
}

NFunc *NFunc::clone() const
{
  return new NFunc(*this);
}



/********************   ModImp    ********************/
ModImp::ModImp(PackageName *p1)
{
  packagename_ = p1;

}

ModImp::ModImp(const ModImp & other)
{
  packagename_ = other.packagename_->clone();

}

ModImp &ModImp::operator=(const ModImp & other)
{
  ModImp tmp(other);
  swap(tmp);
  return *this;
}

void ModImp::swap(ModImp & other)
{
  std::swap(packagename_, other.packagename_);

}

ModImp::~ModImp()
{
  delete(packagename_);

}

void ModImp::accept(Visitor *v)
{
  v->visitModImp(this);
}

ModImp *ModImp::clone() const
{
  return new ModImp(*this);
}



/********************   NPkg    ********************/
NPkg::NPkg(Ident p1)
{
  ident_ = p1;

}

NPkg::NPkg(const NPkg & other)
{
  ident_ = other.ident_;

}

NPkg &NPkg::operator=(const NPkg & other)
{
  NPkg tmp(other);
  swap(tmp);
  return *this;
}

void NPkg::swap(NPkg & other)
{
  std::swap(ident_, other.ident_);

}

NPkg::~NPkg()
{

}

void NPkg::accept(Visitor *v)
{
  v->visitNPkg(this);
}

NPkg *NPkg::clone() const
{
  return new NPkg(*this);
}



/********************   NParam    ********************/
NParam::NParam(VarName *p1)
{
  varname_ = p1;

}

NParam::NParam(const NParam & other)
{
  varname_ = other.varname_->clone();

}

NParam &NParam::operator=(const NParam & other)
{
  NParam tmp(other);
  swap(tmp);
  return *this;
}

void NParam::swap(NParam & other)
{
  std::swap(varname_, other.varname_);

}

NParam::~NParam()
{
  delete(varname_);

}

void NParam::accept(Visitor *v)
{
  v->visitNParam(this);
}

NParam *NParam::clone() const
{
  return new NParam(*this);
}



/********************   TParam    ********************/
TParam::TParam(TypeName *p1)
{
  typename_ = p1;

}

TParam::TParam(const TParam & other)
{
  typename_ = other.typename_->clone();

}

TParam &TParam::operator=(const TParam & other)
{
  TParam tmp(other);
  swap(tmp);
  return *this;
}

void TParam::swap(TParam & other)
{
  std::swap(typename_, other.typename_);

}

TParam::~TParam()
{
  delete(typename_);

}

void TParam::accept(Visitor *v)
{
  v->visitTParam(this);
}

TParam *TParam::clone() const
{
  return new TParam(*this);
}



/********************   NQFunc    ********************/
NQFunc::NQFunc(PackageName *p1, FunctionName *p2)
{
  packagename_ = p1;
  functionname_ = p2;

}

NQFunc::NQFunc(const NQFunc & other)
{
  packagename_ = other.packagename_->clone();
  functionname_ = other.functionname_->clone();

}

NQFunc &NQFunc::operator=(const NQFunc & other)
{
  NQFunc tmp(other);
  swap(tmp);
  return *this;
}

void NQFunc::swap(NQFunc & other)
{
  std::swap(packagename_, other.packagename_);
  std::swap(functionname_, other.functionname_);

}

NQFunc::~NQFunc()
{
  delete(packagename_);
  delete(functionname_);

}

void NQFunc::accept(Visitor *v)
{
  v->visitNQFunc(this);
}

NQFunc *NQFunc::clone() const
{
  return new NQFunc(*this);
}



/********************   SAssign    ********************/
SAssign::SAssign(QVarName *p1, Exp *p2)
{
  qvarname_ = p1;
  exp_ = p2;

}

SAssign::SAssign(const SAssign & other)
{
  qvarname_ = other.qvarname_->clone();
  exp_ = other.exp_->clone();

}

SAssign &SAssign::operator=(const SAssign & other)
{
  SAssign tmp(other);
  swap(tmp);
  return *this;
}

void SAssign::swap(SAssign & other)
{
  std::swap(qvarname_, other.qvarname_);
  std::swap(exp_, other.exp_);

}

SAssign::~SAssign()
{
  delete(qvarname_);
  delete(exp_);

}

void SAssign::accept(Visitor *v)
{
  v->visitSAssign(this);
}

SAssign *SAssign::clone() const
{
  return new SAssign(*this);
}



/********************   SReturn    ********************/
SReturn::SReturn(Exp *p1)
{
  exp_ = p1;

}

SReturn::SReturn(const SReturn & other)
{
  exp_ = other.exp_->clone();

}

SReturn &SReturn::operator=(const SReturn & other)
{
  SReturn tmp(other);
  swap(tmp);
  return *this;
}

void SReturn::swap(SReturn & other)
{
  std::swap(exp_, other.exp_);

}

SReturn::~SReturn()
{
  delete(exp_);

}

void SReturn::accept(Visitor *v)
{
  v->visitSReturn(this);
}

SReturn *SReturn::clone() const
{
  return new SReturn(*this);
}



/********************   SIf    ********************/
SIf::SIf(Exp *p1, Block *p2)
{
  exp_ = p1;
  block_ = p2;

}

SIf::SIf(const SIf & other)
{
  exp_ = other.exp_->clone();
  block_ = other.block_->clone();

}

SIf &SIf::operator=(const SIf & other)
{
  SIf tmp(other);
  swap(tmp);
  return *this;
}

void SIf::swap(SIf & other)
{
  std::swap(exp_, other.exp_);
  std::swap(block_, other.block_);

}

SIf::~SIf()
{
  delete(exp_);
  delete(block_);

}

void SIf::accept(Visitor *v)
{
  v->visitSIf(this);
}

SIf *SIf::clone() const
{
  return new SIf(*this);
}



/********************   SIfElse    ********************/
SIfElse::SIfElse(Exp *p1, Block *p2, Block *p3)
{
  exp_ = p1;
  block_1 = p2;
  block_2 = p3;

}

SIfElse::SIfElse(const SIfElse & other)
{
  exp_ = other.exp_->clone();
  block_1 = other.block_1->clone();
  block_2 = other.block_2->clone();

}

SIfElse &SIfElse::operator=(const SIfElse & other)
{
  SIfElse tmp(other);
  swap(tmp);
  return *this;
}

void SIfElse::swap(SIfElse & other)
{
  std::swap(exp_, other.exp_);
  std::swap(block_1, other.block_1);
  std::swap(block_2, other.block_2);

}

SIfElse::~SIfElse()
{
  delete(exp_);
  delete(block_1);
  delete(block_2);

}

void SIfElse::accept(Visitor *v)
{
  v->visitSIfElse(this);
}

SIfElse *SIfElse::clone() const
{
  return new SIfElse(*this);
}



/********************   SWith    ********************/
SWith::SWith(Statement *p1)
{
  statement_ = p1;

}

SWith::SWith(const SWith & other)
{
  statement_ = other.statement_->clone();

}

SWith &SWith::operator=(const SWith & other)
{
  SWith tmp(other);
  swap(tmp);
  return *this;
}

void SWith::swap(SWith & other)
{
  std::swap(statement_, other.statement_);

}

SWith::~SWith()
{
  delete(statement_);

}

void SWith::accept(Visitor *v)
{
  v->visitSWith(this);
}

SWith *SWith::clone() const
{
  return new SWith(*this);
}



/********************   SBareStmt    ********************/
SBareStmt::SBareStmt(Exp *p1)
{
  exp_ = p1;

}

SBareStmt::SBareStmt(const SBareStmt & other)
{
  exp_ = other.exp_->clone();

}

SBareStmt &SBareStmt::operator=(const SBareStmt & other)
{
  SBareStmt tmp(other);
  swap(tmp);
  return *this;
}

void SBareStmt::swap(SBareStmt & other)
{
  std::swap(exp_, other.exp_);

}

SBareStmt::~SBareStmt()
{
  delete(exp_);

}

void SBareStmt::accept(Visitor *v)
{
  v->visitSBareStmt(this);
}

SBareStmt *SBareStmt::clone() const
{
  return new SBareStmt(*this);
}



/********************   UriConst    ********************/
UriConst::UriConst(String p1)
{
  string_ = p1;

}

UriConst::UriConst(const UriConst & other)
{
  string_ = other.string_;

}

UriConst &UriConst::operator=(const UriConst & other)
{
  UriConst tmp(other);
  swap(tmp);
  return *this;
}

void UriConst::swap(UriConst & other)
{
  std::swap(string_, other.string_);

}

UriConst::~UriConst()
{

}

void UriConst::accept(Visitor *v)
{
  v->visitUriConst(this);
}

UriConst *UriConst::clone() const
{
  return new UriConst(*this);
}



/********************   VarNameIdent    ********************/
VarNameIdent::VarNameIdent(Ident p1)
{
  ident_ = p1;

}

VarNameIdent::VarNameIdent(const VarNameIdent & other)
{
  ident_ = other.ident_;

}

VarNameIdent &VarNameIdent::operator=(const VarNameIdent & other)
{
  VarNameIdent tmp(other);
  swap(tmp);
  return *this;
}

void VarNameIdent::swap(VarNameIdent & other)
{
  std::swap(ident_, other.ident_);

}

VarNameIdent::~VarNameIdent()
{

}

void VarNameIdent::accept(Visitor *v)
{
  v->visitVarNameIdent(this);
}

VarNameIdent *VarNameIdent::clone() const
{
  return new VarNameIdent(*this);
}



/********************   VarNamePIdent    ********************/
VarNamePIdent::VarNamePIdent(PIdent p1)
{
  pident_ = p1;

}

VarNamePIdent::VarNamePIdent(const VarNamePIdent & other)
{
  pident_ = other.pident_;

}

VarNamePIdent &VarNamePIdent::operator=(const VarNamePIdent & other)
{
  VarNamePIdent tmp(other);
  swap(tmp);
  return *this;
}

void VarNamePIdent::swap(VarNamePIdent & other)
{
  std::swap(pident_, other.pident_);

}

VarNamePIdent::~VarNamePIdent()
{

}

void VarNamePIdent::accept(Visitor *v)
{
  v->visitVarNamePIdent(this);
}

VarNamePIdent *VarNamePIdent::clone() const
{
  return new VarNamePIdent(*this);
}



/********************   VarNameUIdent    ********************/
VarNameUIdent::VarNameUIdent(UIdent p1)
{
  uident_ = p1;

}

VarNameUIdent::VarNameUIdent(const VarNameUIdent & other)
{
  uident_ = other.uident_;

}

VarNameUIdent &VarNameUIdent::operator=(const VarNameUIdent & other)
{
  VarNameUIdent tmp(other);
  swap(tmp);
  return *this;
}

void VarNameUIdent::swap(VarNameUIdent & other)
{
  std::swap(uident_, other.uident_);

}

VarNameUIdent::~VarNameUIdent()
{

}

void VarNameUIdent::accept(Visitor *v)
{
  v->visitVarNameUIdent(this);
}

VarNameUIdent *VarNameUIdent::clone() const
{
  return new VarNameUIdent(*this);
}



/********************   QVarName1    ********************/
QVarName1::QVarName1(ListVarName *p1)
{
  listvarname_ = p1;

}

QVarName1::QVarName1(const QVarName1 & other)
{
  listvarname_ = other.listvarname_->clone();

}

QVarName1 &QVarName1::operator=(const QVarName1 & other)
{
  QVarName1 tmp(other);
  swap(tmp);
  return *this;
}

void QVarName1::swap(QVarName1 & other)
{
  std::swap(listvarname_, other.listvarname_);

}

QVarName1::~QVarName1()
{
  delete(listvarname_);

}

void QVarName1::accept(Visitor *v)
{
  v->visitQVarName1(this);
}

QVarName1 *QVarName1::clone() const
{
  return new QVarName1(*this);
}



/********************   EAnd    ********************/
EAnd::EAnd(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EAnd::EAnd(const EAnd & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EAnd &EAnd::operator=(const EAnd & other)
{
  EAnd tmp(other);
  swap(tmp);
  return *this;
}

void EAnd::swap(EAnd & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EAnd::~EAnd()
{
  delete(exp_1);
  delete(exp_2);

}

void EAnd::accept(Visitor *v)
{
  v->visitEAnd(this);
}

EAnd *EAnd::clone() const
{
  return new EAnd(*this);
}



/********************   EAdd    ********************/
EAdd::EAdd(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EAdd::EAdd(const EAdd & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EAdd &EAdd::operator=(const EAdd & other)
{
  EAdd tmp(other);
  swap(tmp);
  return *this;
}

void EAdd::swap(EAdd & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EAdd::~EAdd()
{
  delete(exp_1);
  delete(exp_2);

}

void EAdd::accept(Visitor *v)
{
  v->visitEAdd(this);
}

EAdd *EAdd::clone() const
{
  return new EAdd(*this);
}



/********************   ESub    ********************/
ESub::ESub(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ESub::ESub(const ESub & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ESub &ESub::operator=(const ESub & other)
{
  ESub tmp(other);
  swap(tmp);
  return *this;
}

void ESub::swap(ESub & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ESub::~ESub()
{
  delete(exp_1);
  delete(exp_2);

}

void ESub::accept(Visitor *v)
{
  v->visitESub(this);
}

ESub *ESub::clone() const
{
  return new ESub(*this);
}



/********************   EMul    ********************/
EMul::EMul(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EMul::EMul(const EMul & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EMul &EMul::operator=(const EMul & other)
{
  EMul tmp(other);
  swap(tmp);
  return *this;
}

void EMul::swap(EMul & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EMul::~EMul()
{
  delete(exp_1);
  delete(exp_2);

}

void EMul::accept(Visitor *v)
{
  v->visitEMul(this);
}

EMul *EMul::clone() const
{
  return new EMul(*this);
}



/********************   EDiv    ********************/
EDiv::EDiv(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EDiv::EDiv(const EDiv & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EDiv &EDiv::operator=(const EDiv & other)
{
  EDiv tmp(other);
  swap(tmp);
  return *this;
}

void EDiv::swap(EDiv & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EDiv::~EDiv()
{
  delete(exp_1);
  delete(exp_2);

}

void EDiv::accept(Visitor *v)
{
  v->visitEDiv(this);
}

EDiv *EDiv::clone() const
{
  return new EDiv(*this);
}



/********************   EInt    ********************/
EInt::EInt(Integer p1)
{
  integer_ = p1;

}

EInt::EInt(const EInt & other)
{
  integer_ = other.integer_;

}

EInt &EInt::operator=(const EInt & other)
{
  EInt tmp(other);
  swap(tmp);
  return *this;
}

void EInt::swap(EInt & other)
{
  std::swap(integer_, other.integer_);

}

EInt::~EInt()
{

}

void EInt::accept(Visitor *v)
{
  v->visitEInt(this);
}

EInt *EInt::clone() const
{
  return new EInt(*this);
}



/********************   EDouble    ********************/
EDouble::EDouble(Double p1)
{
  double_ = p1;

}

EDouble::EDouble(const EDouble & other)
{
  double_ = other.double_;

}

EDouble &EDouble::operator=(const EDouble & other)
{
  EDouble tmp(other);
  swap(tmp);
  return *this;
}

void EDouble::swap(EDouble & other)
{
  std::swap(double_, other.double_);

}

EDouble::~EDouble()
{

}

void EDouble::accept(Visitor *v)
{
  v->visitEDouble(this);
}

EDouble *EDouble::clone() const
{
  return new EDouble(*this);
}



/********************   EString    ********************/
EString::EString(String p1)
{
  string_ = p1;

}

EString::EString(const EString & other)
{
  string_ = other.string_;

}

EString &EString::operator=(const EString & other)
{
  EString tmp(other);
  swap(tmp);
  return *this;
}

void EString::swap(EString & other)
{
  std::swap(string_, other.string_);

}

EString::~EString()
{

}

void EString::accept(Visitor *v)
{
  v->visitEString(this);
}

EString *EString::clone() const
{
  return new EString(*this);
}



/********************   EVarname    ********************/
EVarname::EVarname(QVarName *p1)
{
  qvarname_ = p1;

}

EVarname::EVarname(const EVarname & other)
{
  qvarname_ = other.qvarname_->clone();

}

EVarname &EVarname::operator=(const EVarname & other)
{
  EVarname tmp(other);
  swap(tmp);
  return *this;
}

void EVarname::swap(EVarname & other)
{
  std::swap(qvarname_, other.qvarname_);

}

EVarname::~EVarname()
{
  delete(qvarname_);

}

void EVarname::accept(Visitor *v)
{
  v->visitEVarname(this);
}

EVarname *EVarname::clone() const
{
  return new EVarname(*this);
}



/********************   EFuncCall    ********************/
EFuncCall::EFuncCall(FunctionName *p1, ListExp *p2)
{
  functionname_ = p1;
  listexp_ = p2;

}

EFuncCall::EFuncCall(const EFuncCall & other)
{
  functionname_ = other.functionname_->clone();
  listexp_ = other.listexp_->clone();

}

EFuncCall &EFuncCall::operator=(const EFuncCall & other)
{
  EFuncCall tmp(other);
  swap(tmp);
  return *this;
}

void EFuncCall::swap(EFuncCall & other)
{
  std::swap(functionname_, other.functionname_);
  std::swap(listexp_, other.listexp_);

}

EFuncCall::~EFuncCall()
{
  delete(functionname_);
  delete(listexp_);

}

void EFuncCall::accept(Visitor *v)
{
  v->visitEFuncCall(this);
}

EFuncCall *EFuncCall::clone() const
{
  return new EFuncCall(*this);
}



/********************   EQFuncCall    ********************/
EQFuncCall::EQFuncCall(QVarName *p1, ListExp *p2)
{
  qvarname_ = p1;
  listexp_ = p2;

}

EQFuncCall::EQFuncCall(const EQFuncCall & other)
{
  qvarname_ = other.qvarname_->clone();
  listexp_ = other.listexp_->clone();

}

EQFuncCall &EQFuncCall::operator=(const EQFuncCall & other)
{
  EQFuncCall tmp(other);
  swap(tmp);
  return *this;
}

void EQFuncCall::swap(EQFuncCall & other)
{
  std::swap(qvarname_, other.qvarname_);
  std::swap(listexp_, other.listexp_);

}

EQFuncCall::~EQFuncCall()
{
  delete(qvarname_);
  delete(listexp_);

}

void EQFuncCall::accept(Visitor *v)
{
  v->visitEQFuncCall(this);
}

EQFuncCall *EQFuncCall::clone() const
{
  return new EQFuncCall(*this);
}



/********************   EFuncParen    ********************/
EFuncParen::EFuncParen(Exp *p1)
{
  exp_ = p1;

}

EFuncParen::EFuncParen(const EFuncParen & other)
{
  exp_ = other.exp_->clone();

}

EFuncParen &EFuncParen::operator=(const EFuncParen & other)
{
  EFuncParen tmp(other);
  swap(tmp);
  return *this;
}

void EFuncParen::swap(EFuncParen & other)
{
  std::swap(exp_, other.exp_);

}

EFuncParen::~EFuncParen()
{
  delete(exp_);

}

void EFuncParen::accept(Visitor *v)
{
  v->visitEFuncParen(this);
}

EFuncParen *EFuncParen::clone() const
{
  return new EFuncParen(*this);
}



/********************   ENegation    ********************/
ENegation::ENegation(Exp *p1)
{
  exp_ = p1;

}

ENegation::ENegation(const ENegation & other)
{
  exp_ = other.exp_->clone();

}

ENegation &ENegation::operator=(const ENegation & other)
{
  ENegation tmp(other);
  swap(tmp);
  return *this;
}

void ENegation::swap(ENegation & other)
{
  std::swap(exp_, other.exp_);

}

ENegation::~ENegation()
{
  delete(exp_);

}

void ENegation::accept(Visitor *v)
{
  v->visitENegation(this);
}

ENegation *ENegation::clone() const
{
  return new ENegation(*this);
}



/********************   ETypeCreate    ********************/
ETypeCreate::ETypeCreate(TypeInitialiser *p1)
{
  typeinitialiser_ = p1;

}

ETypeCreate::ETypeCreate(const ETypeCreate & other)
{
  typeinitialiser_ = other.typeinitialiser_->clone();

}

ETypeCreate &ETypeCreate::operator=(const ETypeCreate & other)
{
  ETypeCreate tmp(other);
  swap(tmp);
  return *this;
}

void ETypeCreate::swap(ETypeCreate & other)
{
  std::swap(typeinitialiser_, other.typeinitialiser_);

}

ETypeCreate::~ETypeCreate()
{
  delete(typeinitialiser_);

}

void ETypeCreate::accept(Visitor *v)
{
  v->visitETypeCreate(this);
}

ETypeCreate *ETypeCreate::clone() const
{
  return new ETypeCreate(*this);
}



/********************   TypeInt    ********************/
TypeInt::TypeInt(TypeName *p1, ListTypePropertyInit *p2)
{
  typename_ = p1;
  listtypepropertyinit_ = p2;

}

TypeInt::TypeInt(const TypeInt & other)
{
  typename_ = other.typename_->clone();
  listtypepropertyinit_ = other.listtypepropertyinit_->clone();

}

TypeInt &TypeInt::operator=(const TypeInt & other)
{
  TypeInt tmp(other);
  swap(tmp);
  return *this;
}

void TypeInt::swap(TypeInt & other)
{
  std::swap(typename_, other.typename_);
  std::swap(listtypepropertyinit_, other.listtypepropertyinit_);

}

TypeInt::~TypeInt()
{
  delete(typename_);
  delete(listtypepropertyinit_);

}

void TypeInt::accept(Visitor *v)
{
  v->visitTypeInt(this);
}

TypeInt *TypeInt::clone() const
{
  return new TypeInt(*this);
}



/********************   NTypeName    ********************/
NTypeName::NTypeName(QVarName *p1)
{
  qvarname_ = p1;

}

NTypeName::NTypeName(const NTypeName & other)
{
  qvarname_ = other.qvarname_->clone();

}

NTypeName &NTypeName::operator=(const NTypeName & other)
{
  NTypeName tmp(other);
  swap(tmp);
  return *this;
}

void NTypeName::swap(NTypeName & other)
{
  std::swap(qvarname_, other.qvarname_);

}

NTypeName::~NTypeName()
{
  delete(qvarname_);

}

void NTypeName::accept(Visitor *v)
{
  v->visitNTypeName(this);
}

NTypeName *NTypeName::clone() const
{
  return new NTypeName(*this);
}



/********************   TypePropertyInit1    ********************/
TypePropertyInit1::TypePropertyInit1(VarName *p1, Exp *p2)
{
  varname_ = p1;
  exp_ = p2;

}

TypePropertyInit1::TypePropertyInit1(const TypePropertyInit1 & other)
{
  varname_ = other.varname_->clone();
  exp_ = other.exp_->clone();

}

TypePropertyInit1 &TypePropertyInit1::operator=(const TypePropertyInit1 & other)
{
  TypePropertyInit1 tmp(other);
  swap(tmp);
  return *this;
}

void TypePropertyInit1::swap(TypePropertyInit1 & other)
{
  std::swap(varname_, other.varname_);
  std::swap(exp_, other.exp_);

}

TypePropertyInit1::~TypePropertyInit1()
{
  delete(varname_);
  delete(exp_);

}

void TypePropertyInit1::accept(Visitor *v)
{
  v->visitTypePropertyInit1(this);
}

TypePropertyInit1 *TypePropertyInit1::clone() const
{
  return new TypePropertyInit1(*this);
}




/********************   ListFormalParameter    ********************/

void ListFormalParameter::accept(Visitor *v)
{
  v->visitListFormalParameter(this);
}


ListFormalParameter *ListFormalParameter::clone() const
{
  return new ListFormalParameter(*this);
}


/********************   ListExp    ********************/

void ListExp::accept(Visitor *v)
{
  v->visitListExp(this);
}


ListExp *ListExp::clone() const
{
  return new ListExp(*this);
}


/********************   ListTypePropertyInit    ********************/

void ListTypePropertyInit::accept(Visitor *v)
{
  v->visitListTypePropertyInit(this);
}


ListTypePropertyInit *ListTypePropertyInit::clone() const
{
  return new ListTypePropertyInit(*this);
}


/********************   ListVarName    ********************/

void ListVarName::accept(Visitor *v)
{
  v->visitListVarName(this);
}


ListVarName *ListVarName::clone() const
{
  return new ListVarName(*this);
}


/********************   ListAlias    ********************/

void ListAlias::accept(Visitor *v)
{
  v->visitListAlias(this);
}


ListAlias *ListAlias::clone() const
{
  return new ListAlias(*this);
}


/********************   ListFunctionDeclaration    ********************/

void ListFunctionDeclaration::accept(Visitor *v)
{
  v->visitListFunctionDeclaration(this);
}


ListFunctionDeclaration *ListFunctionDeclaration::clone() const
{
  return new ListFunctionDeclaration(*this);
}


/********************   ListModuleImport    ********************/

void ListModuleImport::accept(Visitor *v)
{
  v->visitListModuleImport(this);
}


ListModuleImport *ListModuleImport::clone() const
{
  return new ListModuleImport(*this);
}


/********************   ListStatement    ********************/

void ListStatement::accept(Visitor *v)
{
  v->visitListStatement(this);
}


ListStatement *ListStatement::clone() const
{
  return new ListStatement(*this);
}




