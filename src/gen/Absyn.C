//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <vector>
#include "Absyn.H"

/********************   FifthProgram    ********************/
FifthProgram::FifthProgram(ListModuleImport *p1, ListFunctionDeclaration *p2)
{
  listmoduleimport_ = p1;
  listfunctiondeclaration_ = p2;

}

FifthProgram::FifthProgram(const FifthProgram & other)
{
  listmoduleimport_ = other.listmoduleimport_->clone();
  listfunctiondeclaration_ = other.listfunctiondeclaration_->clone();

}

FifthProgram &FifthProgram::operator=(const FifthProgram & other)
{
  FifthProgram tmp(other);
  swap(tmp);
  return *this;
}

void FifthProgram::swap(FifthProgram & other)
{
  std::swap(listmoduleimport_, other.listmoduleimport_);
  std::swap(listfunctiondeclaration_, other.listfunctiondeclaration_);

}

FifthProgram::~FifthProgram()
{
  delete(listmoduleimport_);
  delete(listfunctiondeclaration_);

}

void FifthProgram::accept(Visitor *v)
{
  v->visitFifthProgram(this);
}

FifthProgram *FifthProgram::clone() const
{
  return new FifthProgram(*this);
}



/********************   ModImp    ********************/
ModImp::ModImp(PackageName *p1)
{
  packagename_ = p1;

}

ModImp::ModImp(const ModImp & other)
{
  packagename_ = other.packagename_->clone();

}

ModImp &ModImp::operator=(const ModImp & other)
{
  ModImp tmp(other);
  swap(tmp);
  return *this;
}

void ModImp::swap(ModImp & other)
{
  std::swap(packagename_, other.packagename_);

}

ModImp::~ModImp()
{
  delete(packagename_);

}

void ModImp::accept(Visitor *v)
{
  v->visitModImp(this);
}

ModImp *ModImp::clone() const
{
  return new ModImp(*this);
}



/********************   FuncDecl    ********************/
FuncDecl::FuncDecl(FunctionName *p1, ListFormalParameter *p2, ListExp *p3)
{
  functionname_ = p1;
  listformalparameter_ = p2;
  listexp_ = p3;

}

FuncDecl::FuncDecl(const FuncDecl & other)
{
  functionname_ = other.functionname_->clone();
  listformalparameter_ = other.listformalparameter_->clone();
  listexp_ = other.listexp_->clone();

}

FuncDecl &FuncDecl::operator=(const FuncDecl & other)
{
  FuncDecl tmp(other);
  swap(tmp);
  return *this;
}

void FuncDecl::swap(FuncDecl & other)
{
  std::swap(functionname_, other.functionname_);
  std::swap(listformalparameter_, other.listformalparameter_);
  std::swap(listexp_, other.listexp_);

}

FuncDecl::~FuncDecl()
{
  delete(functionname_);
  delete(listformalparameter_);
  delete(listexp_);

}

void FuncDecl::accept(Visitor *v)
{
  v->visitFuncDecl(this);
}

FuncDecl *FuncDecl::clone() const
{
  return new FuncDecl(*this);
}



/********************   FParam    ********************/
FParam::FParam(ParamType *p1, ParamName *p2)
{
  paramtype_ = p1;
  paramname_ = p2;

}

FParam::FParam(const FParam & other)
{
  paramtype_ = other.paramtype_->clone();
  paramname_ = other.paramname_->clone();

}

FParam &FParam::operator=(const FParam & other)
{
  FParam tmp(other);
  swap(tmp);
  return *this;
}

void FParam::swap(FParam & other)
{
  std::swap(paramtype_, other.paramtype_);
  std::swap(paramname_, other.paramname_);

}

FParam::~FParam()
{
  delete(paramtype_);
  delete(paramname_);

}

void FParam::accept(Visitor *v)
{
  v->visitFParam(this);
}

FParam *FParam::clone() const
{
  return new FParam(*this);
}



/********************   TParam    ********************/
TParam::TParam(Ident p1)
{
  ident_ = p1;

}

TParam::TParam(const TParam & other)
{
  ident_ = other.ident_;

}

TParam &TParam::operator=(const TParam & other)
{
  TParam tmp(other);
  swap(tmp);
  return *this;
}

void TParam::swap(TParam & other)
{
  std::swap(ident_, other.ident_);

}

TParam::~TParam()
{

}

void TParam::accept(Visitor *v)
{
  v->visitTParam(this);
}

TParam *TParam::clone() const
{
  return new TParam(*this);
}



/********************   NParam    ********************/
NParam::NParam(Ident p1)
{
  ident_ = p1;

}

NParam::NParam(const NParam & other)
{
  ident_ = other.ident_;

}

NParam &NParam::operator=(const NParam & other)
{
  NParam tmp(other);
  swap(tmp);
  return *this;
}

void NParam::swap(NParam & other)
{
  std::swap(ident_, other.ident_);

}

NParam::~NParam()
{

}

void NParam::accept(Visitor *v)
{
  v->visitNParam(this);
}

NParam *NParam::clone() const
{
  return new NParam(*this);
}



/********************   NQFunc    ********************/
NQFunc::NQFunc(PackageName *p1, FunctionName *p2)
{
  packagename_ = p1;
  functionname_ = p2;

}

NQFunc::NQFunc(const NQFunc & other)
{
  packagename_ = other.packagename_->clone();
  functionname_ = other.functionname_->clone();

}

NQFunc &NQFunc::operator=(const NQFunc & other)
{
  NQFunc tmp(other);
  swap(tmp);
  return *this;
}

void NQFunc::swap(NQFunc & other)
{
  std::swap(packagename_, other.packagename_);
  std::swap(functionname_, other.functionname_);

}

NQFunc::~NQFunc()
{
  delete(packagename_);
  delete(functionname_);

}

void NQFunc::accept(Visitor *v)
{
  v->visitNQFunc(this);
}

NQFunc *NQFunc::clone() const
{
  return new NQFunc(*this);
}



/********************   NFunc    ********************/
NFunc::NFunc(Ident p1)
{
  ident_ = p1;

}

NFunc::NFunc(const NFunc & other)
{
  ident_ = other.ident_;

}

NFunc &NFunc::operator=(const NFunc & other)
{
  NFunc tmp(other);
  swap(tmp);
  return *this;
}

void NFunc::swap(NFunc & other)
{
  std::swap(ident_, other.ident_);

}

NFunc::~NFunc()
{

}

void NFunc::accept(Visitor *v)
{
  v->visitNFunc(this);
}

NFunc *NFunc::clone() const
{
  return new NFunc(*this);
}



/********************   NPkg    ********************/
NPkg::NPkg(Ident p1)
{
  ident_ = p1;

}

NPkg::NPkg(const NPkg & other)
{
  ident_ = other.ident_;

}

NPkg &NPkg::operator=(const NPkg & other)
{
  NPkg tmp(other);
  swap(tmp);
  return *this;
}

void NPkg::swap(NPkg & other)
{
  std::swap(ident_, other.ident_);

}

NPkg::~NPkg()
{

}

void NPkg::accept(Visitor *v)
{
  v->visitNPkg(this);
}

NPkg *NPkg::clone() const
{
  return new NPkg(*this);
}



/********************   EAdd    ********************/
EAdd::EAdd(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EAdd::EAdd(const EAdd & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EAdd &EAdd::operator=(const EAdd & other)
{
  EAdd tmp(other);
  swap(tmp);
  return *this;
}

void EAdd::swap(EAdd & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EAdd::~EAdd()
{
  delete(exp_1);
  delete(exp_2);

}

void EAdd::accept(Visitor *v)
{
  v->visitEAdd(this);
}

EAdd *EAdd::clone() const
{
  return new EAdd(*this);
}



/********************   ESub    ********************/
ESub::ESub(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

ESub::ESub(const ESub & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

ESub &ESub::operator=(const ESub & other)
{
  ESub tmp(other);
  swap(tmp);
  return *this;
}

void ESub::swap(ESub & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

ESub::~ESub()
{
  delete(exp_1);
  delete(exp_2);

}

void ESub::accept(Visitor *v)
{
  v->visitESub(this);
}

ESub *ESub::clone() const
{
  return new ESub(*this);
}



/********************   EMul    ********************/
EMul::EMul(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EMul::EMul(const EMul & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EMul &EMul::operator=(const EMul & other)
{
  EMul tmp(other);
  swap(tmp);
  return *this;
}

void EMul::swap(EMul & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EMul::~EMul()
{
  delete(exp_1);
  delete(exp_2);

}

void EMul::accept(Visitor *v)
{
  v->visitEMul(this);
}

EMul *EMul::clone() const
{
  return new EMul(*this);
}



/********************   EDiv    ********************/
EDiv::EDiv(Exp *p1, Exp *p2)
{
  exp_1 = p1;
  exp_2 = p2;

}

EDiv::EDiv(const EDiv & other)
{
  exp_1 = other.exp_1->clone();
  exp_2 = other.exp_2->clone();

}

EDiv &EDiv::operator=(const EDiv & other)
{
  EDiv tmp(other);
  swap(tmp);
  return *this;
}

void EDiv::swap(EDiv & other)
{
  std::swap(exp_1, other.exp_1);
  std::swap(exp_2, other.exp_2);

}

EDiv::~EDiv()
{
  delete(exp_1);
  delete(exp_2);

}

void EDiv::accept(Visitor *v)
{
  v->visitEDiv(this);
}

EDiv *EDiv::clone() const
{
  return new EDiv(*this);
}



/********************   EInt    ********************/
EInt::EInt(Integer p1)
{
  integer_ = p1;

}

EInt::EInt(const EInt & other)
{
  integer_ = other.integer_;

}

EInt &EInt::operator=(const EInt & other)
{
  EInt tmp(other);
  swap(tmp);
  return *this;
}

void EInt::swap(EInt & other)
{
  std::swap(integer_, other.integer_);

}

EInt::~EInt()
{

}

void EInt::accept(Visitor *v)
{
  v->visitEInt(this);
}

EInt *EInt::clone() const
{
  return new EInt(*this);
}



/********************   EDouble    ********************/
EDouble::EDouble(Double p1)
{
  double_ = p1;

}

EDouble::EDouble(const EDouble & other)
{
  double_ = other.double_;

}

EDouble &EDouble::operator=(const EDouble & other)
{
  EDouble tmp(other);
  swap(tmp);
  return *this;
}

void EDouble::swap(EDouble & other)
{
  std::swap(double_, other.double_);

}

EDouble::~EDouble()
{

}

void EDouble::accept(Visitor *v)
{
  v->visitEDouble(this);
}

EDouble *EDouble::clone() const
{
  return new EDouble(*this);
}



/********************   EIdent    ********************/
EIdent::EIdent(Ident p1)
{
  ident_ = p1;

}

EIdent::EIdent(const EIdent & other)
{
  ident_ = other.ident_;

}

EIdent &EIdent::operator=(const EIdent & other)
{
  EIdent tmp(other);
  swap(tmp);
  return *this;
}

void EIdent::swap(EIdent & other)
{
  std::swap(ident_, other.ident_);

}

EIdent::~EIdent()
{

}

void EIdent::accept(Visitor *v)
{
  v->visitEIdent(this);
}

EIdent *EIdent::clone() const
{
  return new EIdent(*this);
}



/********************   EString    ********************/
EString::EString(String p1)
{
  string_ = p1;

}

EString::EString(const EString & other)
{
  string_ = other.string_;

}

EString &EString::operator=(const EString & other)
{
  EString tmp(other);
  swap(tmp);
  return *this;
}

void EString::swap(EString & other)
{
  std::swap(string_, other.string_);

}

EString::~EString()
{

}

void EString::accept(Visitor *v)
{
  v->visitEString(this);
}

EString *EString::clone() const
{
  return new EString(*this);
}



/********************   EFuncCall    ********************/
EFuncCall::EFuncCall(FunctionName *p1, ListExp *p2)
{
  functionname_ = p1;
  listexp_ = p2;

}

EFuncCall::EFuncCall(const EFuncCall & other)
{
  functionname_ = other.functionname_->clone();
  listexp_ = other.listexp_->clone();

}

EFuncCall &EFuncCall::operator=(const EFuncCall & other)
{
  EFuncCall tmp(other);
  swap(tmp);
  return *this;
}

void EFuncCall::swap(EFuncCall & other)
{
  std::swap(functionname_, other.functionname_);
  std::swap(listexp_, other.listexp_);

}

EFuncCall::~EFuncCall()
{
  delete(functionname_);
  delete(listexp_);

}

void EFuncCall::accept(Visitor *v)
{
  v->visitEFuncCall(this);
}

EFuncCall *EFuncCall::clone() const
{
  return new EFuncCall(*this);
}



/********************   EQFuncCall    ********************/
EQFuncCall::EQFuncCall(QFunctionName *p1, ListExp *p2)
{
  qfunctionname_ = p1;
  listexp_ = p2;

}

EQFuncCall::EQFuncCall(const EQFuncCall & other)
{
  qfunctionname_ = other.qfunctionname_->clone();
  listexp_ = other.listexp_->clone();

}

EQFuncCall &EQFuncCall::operator=(const EQFuncCall & other)
{
  EQFuncCall tmp(other);
  swap(tmp);
  return *this;
}

void EQFuncCall::swap(EQFuncCall & other)
{
  std::swap(qfunctionname_, other.qfunctionname_);
  std::swap(listexp_, other.listexp_);

}

EQFuncCall::~EQFuncCall()
{
  delete(qfunctionname_);
  delete(listexp_);

}

void EQFuncCall::accept(Visitor *v)
{
  v->visitEQFuncCall(this);
}

EQFuncCall *EQFuncCall::clone() const
{
  return new EQFuncCall(*this);
}



/********************   EFuncParen    ********************/
EFuncParen::EFuncParen(ListExp *p1)
{
  listexp_ = p1;

}

EFuncParen::EFuncParen(const EFuncParen & other)
{
  listexp_ = other.listexp_->clone();

}

EFuncParen &EFuncParen::operator=(const EFuncParen & other)
{
  EFuncParen tmp(other);
  swap(tmp);
  return *this;
}

void EFuncParen::swap(EFuncParen & other)
{
  std::swap(listexp_, other.listexp_);

}

EFuncParen::~EFuncParen()
{
  delete(listexp_);

}

void EFuncParen::accept(Visitor *v)
{
  v->visitEFuncParen(this);
}

EFuncParen *EFuncParen::clone() const
{
  return new EFuncParen(*this);
}




/********************   ListModuleImport    ********************/

void ListModuleImport::accept(Visitor *v)
{
  v->visitListModuleImport(this);
}


ListModuleImport *ListModuleImport::clone() const
{
  return new ListModuleImport(*this);
}


/********************   ListFunctionDeclaration    ********************/

void ListFunctionDeclaration::accept(Visitor *v)
{
  v->visitListFunctionDeclaration(this);
}


ListFunctionDeclaration *ListFunctionDeclaration::clone() const
{
  return new ListFunctionDeclaration(*this);
}


/********************   ListFormalParameter    ********************/

void ListFormalParameter::accept(Visitor *v)
{
  v->visitListFormalParameter(this);
}


ListFormalParameter *ListFormalParameter::clone() const
{
  return new ListFormalParameter(*this);
}


/********************   ListExp    ********************/

void ListExp::accept(Visitor *v)
{
  v->visitListExp(this);
}


ListExp *ListExp::clone() const
{
  return new ListExp(*this);
}




